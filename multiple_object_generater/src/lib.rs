use clap::Parser;
use serde::{Deserialize, Serialize};

#[derive(Parser)]
pub struct Args {
    /// json file
    #[clap(short, long)]
    pub json_file: String,

    /// output file
    #[clap(short, long)]
    pub output_file: String,

    #[clap(short, long)]
    pub module_name: Option<String>,
}

#[derive(Serialize, Deserialize)]
pub struct NocConfig {
    number_of_instances: u32,
    instances_info: Vec<InstanceInfo>,
    number_of_events: u32,
    events: Vec<Event>,
}

#[derive(Serialize, Deserialize)]
struct InstanceInfo {
    instance_id: u32,
    instance_name: InstanceName,
}

#[derive(Serialize, Deserialize)]
enum InstanceName {
    #[serde(rename = "cordinater")]
    Cordinater,
    #[serde(rename = "router")]
    Router,
}

#[derive(Serialize, Deserialize)]
pub struct Event {
    timer: u32,
    instances: Vec<Instance>,
}

#[derive(Serialize, Deserialize)]
pub struct Instance {
    instance_name: u32,
    neighbor: Vec<u32>,
}

impl NocConfig {
    fn sort_by_timer(&mut self) {
        self.events.sort_by(|a, b| a.timer.cmp(&b.timer));
    }
    pub fn generate_system_verilog(&mut self, module_name: &str) -> String {
        self.sort_by_timer();

        let max_timer = self.events.last().unwrap().timer;
        let width_of_timer = (max_timer as f64).log2().ceil() as u32;

        let mut system_verilog = format!(
            "/// Automatically generated by multiple_object_generater
module {module_name} (
    input wire clk,
    input wire rst_n
);

    wire [{width_of_timer}:0] timer;

    always @(posedge clk) begin
        if (!rst_n) begin
            timer <= 0;
        end else if (timer < {max_timer}) begin
            timer <= timer + 1;
        end
    end"
        );
        for info in &self.instances_info {
            let i = info.instance_id;
            let is_cordinater = match info.instance_name {
                InstanceName::Cordinater => 1,
                InstanceName::Router => 0,
            };
            let seed = rand::random::<u32>();
            system_verilog.push_str(&format!(
                "

    wire [127:0] chip{i}_rx;
    wire chip{i}_rx_vld;
    reg [127:0] chip{i}_tx;
    reg chip{i}_tx_vld;
    shapechangeable_chip #(
        .IS_ROOT({is_cordinater}),
        .RANDOM_SEED({seed})
    ) chip{i} (
        .flit_rx(chip{i}_rx),
        .flit_rx_vld(chip{i}_rx_vld),
        .flit_tx(chip{i}_tx),
        .flit_tx_vld(chip{i}_tx_vld)
    );"
            ));
        }

        system_verilog.push_str(
            "
    always @(*) begin",
        );
        for i in 0..self.number_of_instances {
            system_verilog.push_str(&format!(
                "
        chip{i}_tx = 0;
        chip{i}_tx_vld = 0;"
            ));
        }
        system_verilog.push_str(
            "
        if (0) begin
            // dummy",
        );

        for event in &self.events {
            let timer = event.timer;
            system_verilog.push_str(&format!(
                "
        end else if (timer < {timer}) begin"
            ));
            for instance in &event.instances {
                let name = instance.instance_name;
                let mut tmp = format!("chip{name}_rx = chip{name}_tx");
                for neighbor in &instance.neighbor {
                    tmp += format!(" | chip{neighbor}_tx", neighbor = neighbor).as_str();
                }
                tmp += ";";
                system_verilog.push_str(&format!(
                    "
            {tmp}"
                ));

                let mut tmp = format!("chip{name}_rx_vld = chip{name}_tx_vld");
                for neighbor in &instance.neighbor {
                    tmp += format!(" | chip{neighbor}_tx_vld", neighbor = neighbor).as_str();
                }
                tmp += ";";
                system_verilog.push_str(&format!(
                    "
            {tmp}"
                ));
            }
        }

        system_verilog.push_str(
            "
        end else begin
        end
    end
endmodule
",
        );
        system_verilog
    }
}
